-- @path VBPMN=/variabilityBPMNtoBPMN/3_ATL_Metamodel/BPMN20.ecore
-- @path BPMN=/variabilityBPMNtoBPMN/3_ATL_Metamodel/BPMN20.ecore

module DeriveVarBPMN;

create OUT : BPMN from IN : VBPMN;

helper context VBPMN!BaseElement def: isExcluded : Boolean =
	self.documentation->notEmpty() and
	self.documentation->exists(d | 
		let docText : String = d.mixed->iterate(e; acc : String = '' |
			acc + e.toString()
		) in
		docText.indexOf('exclude') >= 0
	);

helper context VBPMN!BaseElement def: isSkipped : Boolean =
	self.documentation->notEmpty() and
	self.documentation->exists(d | 
		let docText : String = d.mixed->iterate(e; acc : String = '' |
			acc + e.toString()
		) in
		docText.indexOf('skip') >= 0
	);

helper context VBPMN!FlowElement def: isInExcludedContainer : Boolean =
	if self.refImmediateComposite().oclIsUndefined() then
		false
	else
		if self.refImmediateComposite().oclIsKindOf(VBPMN!SubProcess) then
			self.refImmediateComposite().isExcluded
		else
			false
		endif
	endif;

helper context VBPMN!FlowNode def: getNextValidTarget : VBPMN!FlowNode =
	if not self.isSkipped then
		self
	else
		-- get element after exclusion element
		if self.outgoing->isEmpty() or self.outgoing->first().targetRef.oclIsUndefined() then
			OclUndefined -- Safety check for dead ends
		else
			self.outgoing->first().targetRef.getNextValidTarget
		endif
	endif;

-- Transform Definitions (root container)
rule Definitions {
	from s : VBPMN!Definitions
	to t : BPMN!Definitions (
		id <- s.id,
		name <- s.name,
		targetNamespace <- s.targetNamespace,
		exporter <- s.exporter,
		exporterVersion <- s.exporterVersion,
		rootElements <- s.rootElements
	)
}

-- Transform Process
rule Process {
	from s : VBPMN!Process
	to t : BPMN!Process (
		id <- s.id,
		name <- s.name,
		isExecutable <- s.isExecutable,
		flowElements <- s.flowElements
	)
}

rule ReconnectSequenceFlow {
	from
		s : VBPMN!SequenceFlow (
			not s.sourceRef.isExcluded and
			not s.isInExcludedContainer
		)
	to
		t : BPMN!SequenceFlow (
			id <- s.id,
			name <- s.name,
			
			sourceRef <- s.sourceRef,
			
			targetRef <- s.targetRef.getNextValidTarget
		)	
}


-- Keep other element

rule StartEvent {
	from s : VBPMN!StartEvent (
		not s.isExcluded and
		not s.isInExcludedContainer
	)
	to t : BPMN!StartEvent (
		id <- s.id, name <- s.name
	)
}

rule EndEvent {
	from s : VBPMN!EndEvent (
		not s.isExcluded and
		not s.isInExcludedContainer
	)
	to t : BPMN!EndEvent (
		id <- s.id, name <- s.name
	)
}

rule ExclusiveGateway {
	from s : VBPMN!ExclusiveGateway (
		not s.isExcluded and
		not s.isInExcludedContainer
	)
	to t : BPMN!ExclusiveGateway (
		id <- s.id, name <- s.name
	)
}

rule ParallelGateway {
	from s : VBPMN!ParallelGateway (
		not s.isExcluded and
		not s.isInExcludedContainer
	)
	to t : BPMN!ParallelGateway (
		id <- s.id, name <- s.name
	)
}

rule InclusiveGateway {
	from s : VBPMN!InclusiveGateway (
		not s.isExcluded and
		not s.isInExcludedContainer
	)
	to t : BPMN!InclusiveGateway (
		id <- s.id, name <- s.name
	)
}

rule ReceiveTask {
	from s: VBPMN!ReceiveTask (
		not s.isExcluded and
		not s.isInExcludedContainer
	)
	to t: BPMN!ReceiveTask (
		id <- s.id, name <- s.name	
	)
}

rule UserTask {
	from s: VBPMN!UserTask (
		not s.isExcluded and
		not s.isInExcludedContainer
	)
	to t: BPMN!UserTask (
		id <- s.id, name <- s.name
	)
}

rule ManualTask {
	from s: VBPMN!ManualTask (
		not s.isExcluded and
		not s.isInExcludedContainer
	)
	to t: BPMN!ManualTask (
		id <- s.id, name <- s.name
	)
}

rule SubProcess {
	from s: VBPMN!SubProcess (
		not s.isExcluded
	)
	to t: BPMN!SubProcess (
		id <- s.id,
		name <- s.name,
		triggeredByEvent <- s.triggeredByEvent,
		flowElements <- s.flowElements
	)
}
